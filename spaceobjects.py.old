'''
This file is part of Vyolet.

    Vyolet is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Vyolet is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Vyolet.  If not, see <http://www.gnu.org/licenses/>.
'''

from cmath import polar, rect
from collections import namedtuple
import logging
import math
import struct

import items
from network import str_to_floats
import engineering

# KEEP THIS IN SYNC WITH network packets!!!
RENDER_FMT = '>I10pB8f' # (id, render_cmd, num_args, args,,,,,,,,)
MAX_ARGS = 8

RENDERS = '''
('clear', ),
('color', r, g, b),
('circle', radius),
('line', x1, y1, x2, y2),
('text', text[:32:4])
'''

# KEEP THIS IN SYNC WITH network packets!!!
SHIP_PARTS_FMT = '>32p121H121B' # (parts..., health...)

OPERATE_MAX_DISTANCE = 200
OPERATIONS = {
    'goto':   0b00000001,
    'mine':   0b00000010,
    'target': 0b00000100,
}

# helpers

def render_to_packets(obj_id, render):
    for rndr_cmd in render:
        cmd, args = rndr_cmd[0], rndr_cmd[1:]
        num_args = len(args)
        # fill all unused arg slots with 0
        full_args = (args + MAX_ARGS*(0.,))[:MAX_ARGS]
        yield struct.pack(RENDER_FMT, obj_id, cmd, num_args, *full_args)

def distance(p1, p2):
    '''Distance formula'''
    x1, y1 = p1
    x2, y2 = p2
    return math.sqrt(abs(y2-y1)**2 + abs(x2-x1)**2)

def relative_angle(p1, p2):
    '''Find the angle which p1 would point to p2'''
    x1, y1 = p1
    x2, y2 = p2
    return math.atan2(y2-y1, x2-x1)

Pos = namedtuple('Pos', ['x', 'y'])

# Bases

class SpaceObject(object):
    '''Base class for all space objects'''
    nearby_dist = 1000.
    def __init__(self, **kwargs):
        self.pos = kwargs.pop('pos')
        self.pos_changed = True
        self.direction = kwargs.pop('direction')
        self.others = kwargs.pop('others')
        self.color = kwargs.pop('color')
        self.name = kwargs.pop('name')
        self.id_ = self.others[-1].id_ + 1 if self.others else 1
        self.rerender = True
        self.render_cache = None
        self.dead = False
    @property
    def nearby(self):
        nearby = list()
        for other in self.others:
            if not other.dead and other is not self:
                dist = distance(self.pos, other.pos)
                if dist <= self.nearby_dist:
                    nearby.append(other)
        return nearby
    @property
    def color(self):
        return self._color
    @color.setter
    def color(self, value):
        self._color = tuple(value)
        self.rerender = True
    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value):
        self._name = value
        self.rerender = True
    @property
    def pos(self):
        return self._pos
    @pos.setter
    def pos(self, value):
        self._pos = Pos(*value)
    def get_other_by_id(self, id_):
        if id_ == self.id_:
            return self
        # Uses a binary search to locate an object by id 
        imin = 0
        imax = len(self.others)
        while imin < imax:
            index = int((imax + imin) / 2)
            if self.others[index].id_ < id_:
                imin = index + 1
            elif self.others[index].id_ > id_:
                imax = index
            else:
                return self.others[index]
        raise KeyError
    def get_operations(self):
        return OPERATIONS['goto']
    def operate(self, operator, operation):
        if operation not in OPERATIONS.values():
            logging.warning('invalid operation %i used', operation)
            return
        if not operation & self.get_operations():
            logging.warning('%s does not support operation %i',
                            self.name, operation)
            return
        if operation == OPERATIONS['goto']:
            operator.dest = self
        # the following are distance dependent
        if distance(self.pos, operator.pos) > OPERATE_MAX_DISTANCE:
            return
        if operation == OPERATIONS['mine']:
            operator.cargo += self.mine(operator.stats['mining'])
            operator.cargo = engineering.consolidate_cargo(operator.cargo)
        if operation == OPERATIONS['target']:
            angle = relative_angle(self.pos, operator.pos)
            amount = operator.stats.get('weapon')
            self.damage(angle, amount)
    def render(self):
        return [('clear',), ('color', ) + self.color, ]
    def tick(self):
        if self.rerender:
            self.render_cache = list(render_to_packets(self.id_,
                                                       self.render()))
    def damage(self, angle, amount):
        pass

class NamedSpaceObject(SpaceObject):
    def render(self):
        render = super(NamedSpaceObject, self).render()
        #render.append(('text',) + tuple(str_to_floats(self.name)))
        return render

class SpaceSphere(SpaceObject):
    '''Base class for round space objects'''
    def __init__(self, **kwargs):
        self.size = kwargs.pop('size')
        super(SpaceSphere, self).__init__(**kwargs)
    def render(self):
        render = super(SpaceSphere, self).render()
        render.append(('circle', self.size))
        return render

class DamageSphere(SpaceSphere):
    '''Sub of SpaceSphere that does damage to things that crash into it'''
    def __init__(self, **kwargs):
        super(DamageSphere, self).__init__(**kwargs)
        self.nearby_dist = float(self.size)
    def tick(self):
        super(DamageSphere, self).tick()
        for obj in self.nearby:
            angle = relative_angle(obj.pos, self.pos)
            amount = self.size * math.e**distance(obj.pos, self.pos)
            obj.damage(angle, amount)

class Minable(SpaceObject):
    '''SpaceObject that can be mined for resources'''
    def __init__(self, **kwargs):
        self.mine_seed = kwargs.pop('mine_seed', None) or self.new_mine_seed()
        self.mined_amount = 0
        super(Minable, self).__init__(**kwargs)
        import random
        self.mine_random = random.Random()
    def get_operations(self):
        return OPERATIONS['mine'] | super(Minable, self).get_operations()
    def mine(self, amount):
        # take a Riemann sum at a random point
        end = self.mined_amount + amount
        point = self.mine_random.triangular(self.mined_amount, end)
        mass_mined = amount * self.resource_curve(point)
        result = list()
        for resource in self.mine_seed:
            amount_res = mass_mined * self.mine_seed[resource]
            full_items_count = int(amount_res / 0xff)
            extra = int(amount_res % 0xff)
            if extra:
                result.append((resource, extra))
            for i in range(full_items_count):
                result.append((resource, 0xff))
        return result
    def resource_curve(self, x):
        # x*x is faster in CPy than x**2
        return 1 - (2./math.pi) * math.atan((x*x)/1000.)
    def new_mine_seed(self):
        raise TypeError('Minable subclasses should define new_mine_seed()')

class Satellite(SpaceObject):
    '''For objects that go around other objects'''
    def __init__(self, **kwargs):
        self.orbit_object = kwargs.pop('orbit_object')
        self.orbit_speed = kwargs.pop('orbit_speed')
        super(Satellite, self).__init__(**kwargs)
        self.orbit_angle = relative_angle(self.pos, self.orbit_object.pos)
        self.orbit_distance = distance(self.pos, self.orbit_object.pos)
    def tick(self):
        super(Satellite, self).tick()
        if self.orbit_object is None:
            return
        self.orbit_angle += 2*math.pi * self.orbit_speed
        x = self.orbit_distance*math.cos(self.orbit_angle)
        y = self.orbit_distance*math.sin(self.orbit_angle)
        self.pos_changed = True
        self.pos = (self.orbit_object.pos.x + x,
                    self.orbit_object.pos.y + y)
        if hasattr(self, 'dest'):
            self.dest = self.pos

class Ship(SpaceObject):
    '''Base class for ships'''
    parts_pack_fmt = SHIP_PARTS_FMT
    def __init__(self, **kwargs):
        self.parts = dict()
        self.cargo = list()
        self.stats = dict()
        super(Ship, self).__init__(**kwargs)
        self.dest = self.pos
        self.max_size = 0
    def get_operations(self):
        return OPERATIONS['target'] | super(Ship, self).get_operations()
    @property
    def dest(self):
        if isinstance(self._dest, SpaceObject):
            return self._dest.pos
        return self._dest
    @dest.setter
    def dest(self, value):
        if isinstance(value, SpaceObject):
            self._dest = value
        else:
            self._dest = Pos(*value)
    def get_cargo(self, type_=items.Item):
        cargo = list()
        for item in self.cargo:
            if items.is_type(item[0], type_):
                cargo.append(item)
        return cargo
    def set_part(self, x, y, part):
        if not items.is_type(part[0], (items.ShipPart, items.None_)):
            logging.warning('invalid part')
            return
        if (x,y) == (0,0) and not items.is_type(part[0], items.Cockpit):
            logging.warning('that part cannot go there')
            return
        self.remove_part(x, y, False)
        if not items.is_type(part[0], items.None_):
            self.cargo.remove(part)
            self.parts[(x,y)] = part
        self.check_parts()
    def remove_part(self, x, y, check=True):
        if (x,y) == (0,0) and check:
            return
        self.rerender = True
        if (x, y) in self.parts:
            self.cargo.append(self.parts.pop((x,y)))
            if check:
                self.check_parts()
    def check_parts(self):
        '''Prim's the ship to get rid of floating parts'''
        if not self.parts.has_key((0,0)):
            self.dead = True
            return
        current = (0,0)
        finished = list()
        upcome = list()
        while True:
            cur_x, cur_y = current
            radial = polar(complex(cur_x, cur_y))[0]
            self.max_size = max(radial, self.max_size)
            for rel_x, rel_y in [(1,0),(-1,0),(0,1),(0,-1)]:
                new = (cur_x+rel_x, cur_y+rel_y)
                if new in self.parts and new not in finished:
                    upcome.append((cur_x+rel_x, cur_y+rel_y))
            finished.append(current)
            if not upcome:
                break
            current = upcome.pop(0)
        for check in self.parts.keys():
            if check not in finished:
                self.remove_part(*check)
    def drop(self, item):
        self.cargo.remove(item)
        self.others.append(FloatingItem(item=item, pos=self.pos,
                                        direction=0,
                                        others=self.others,
                                        color=(1,1,1)))
    def restat(self):
        self.stats = dict()
        required = dict()
        for part_id in self.parts.values():
            part = items.get(part_id)
            for req in part.data.pop('require'):
                required.setdefault(req, list()).append(part.id_)
            for stat in part.data:
                if not isinstance(part.data[stat], (int, float)):
                    continue
                if not stat in self.stats:
                    self.stats[stat] = 0
                self.stats[stat] += part.data[stat]
        destat = set()
        for req in required:
            if self.stats[req] <= 0:
                destat.update(set(required[req]))
        for part in destat:
            data = items.get(part).data
            for stat in data:
                self.stats[stat] -= data[stat]
    def pack_parts(self):
        parts = list()
        healths = list()
        for y in xrange(-5, 6):
            for x in xrange(-5, 6):
                part, health = self.parts.get((x,y), (0,0))
                parts.append(part)
                healths.append(health)
        if hasattr(self, 'name'):
            title = self.name
        else:
            title = 'Ship'
        pack_args = ([title,]+parts+healths)
        data = struct.pack(self.parts_pack_fmt, *pack_args)
        return data
    def get_engineering(self):
        return engineering.get_engineering(self.cargo)
    def engineer(self, part):
        self.cargo = engineering.engineer(part, self.cargo)
    def render(self):
        render = super(Ship, self).render()
        for cur_x, cur_y in self.parts:
            for rel_x, rel_y in [(1,0),(-1,0),(0,1),(0,-1)]:
                if not ((cur_x+rel_x, cur_y+rel_y)) in self.parts:
                    if rel_x:
                        points = (10*cur_x+rel_x*5, 10*cur_y+5,
                                  10*cur_x+rel_x*5, 10*cur_y-5)
                        render.append(('line',) + points)
                    elif rel_y:
                        points = (10*cur_x+5, 10*cur_y+rel_y*5,
                                  10*cur_x-5, 10*cur_y+rel_y*5)
                        render.append(('line',) + points)
        return render
    def tick(self):
        self.nearby
        if self.rerender:
            self.restat()
        super(Ship, self).tick()
        self.direction = relative_angle(self.pos, self.dest)
        speed = min(self.stats.get('speed', 0), distance(self.pos, self.dest))
        speed = max(speed, 0) # do not go backwards
        if speed >= 1:
            self.pos_changed = True
        self.pos = (speed*math.cos(self.direction) + self.pos.x,
                    speed*math.sin(self.direction) + self.pos.y)
    def damage(self, angle, amount):
        radial = self.max_size
        while radial >= 0:
            z = rect(radial, angle)
            x, y = int(z.imag), int(z.real)
            if self.parts.has_key((x, y)):
                part, health = self.parts[x,y]
                armor = items.get(part).data['armor']
                health *= armor
                if health > amount:
                    health -= amount
                    health = int(health / armor)
                    self.parts[x,y] = (part, health)
                    return
                else:
                    amount -= health
                    self.parts.pop((x, y))
                    self.rerender = True
                    self.check_parts()
            radial -= 1

# Use these

class Sun(DamageSphere):
    pass

class Planet(DamageSphere, Satellite, Minable):
    def new_mine_seed(self):
        import random
        pre_seed = dict()
        for material in items.get_all(items.RawMaterial):
            item = items.get(material)
            freq = item.data['freq']
            pre_seed[material] = max(0, random.gauss(*freq))
        return pre_seed
        total = sum(pre_seed.values())
        seed = dict()
        for material in pre_seed:
            seed[material] = int(pre_seed[material] / total)
        return seed

class FloatingItem(SpaceObject):
    '''Floating Item like ship part etc.'''
    def __init__(self, **kwargs):
        self.item = kwargs.pop('item')
        super(FloatingItem, self).__init__(**kwargs)
        self.nearby_dist = 10.
    def render(self):
        render = super(FloatingItem, self).render()
        render.append(('circle', 2))
        return render
    def tick(self):
        super(FloatingItem, self).tick()
        for obj in self.nearby:
            if isinstance(obj, PlayerShip):
                obj.cargo.append(self.item)
                self.dead = True
    def damage(self, angle, amount):
        if amount >= 10:
            self.dead = True

class PlayerShip(Ship, NamedSpaceObject):
    '''Ship controlled by a live player'''
    def __init__(self, **kwargs):
        import random
        direction = math.radians(random.randrange(360))
        pos_j = rect(300, direction)
        kwargs.setdefault('pos', (pos_j.real, pos_j.imag))
        kwargs.setdefault('direction', direction)
        kwargs.setdefault('color', (1.,1.,1.))
        self._cargo = list()
        self._backup_cargo = self._cargo[:]
        self._cargo_changed = False
        super(PlayerShip, self).__init__(**kwargs)
        self.parts[0,0] = (0x0001, 0xff)
        self.feedback_events = list()
    @property
    def cargo(self):
        self._cargo_changed = self._cargo_changed or not (
            all(a == b for a, b in zip(self._cargo,
                                       self._backup_cargo)))
        self._backup_cargo = self._cargo[:]
        return self._cargo
    @cargo.setter
    def cargo(self, value):
        self._cargo_changed = True
        self._cargo = value
    def damage(self, angle, amount):
        super(PlayerShip, self).damage(angle, amount)
        self.feedback_events.append(('flash_ui', (0b10000000, 255, 0, 0)))
    def tick(self):
        super(PlayerShip, self).tick()
        self._cargo_changed = self._cargo_changed or not (
            all(a == b for a, b in zip(self._cargo,
                                       self._backup_cargo)))
        if self._cargo_changed:
            self.feedback_events.append(('flash_ui',
                                         (0b00010000, 0, 0, 255)))
            self._cargo_changed = False
    def run_feedback_events(self, speak):
        while self.feedback_events:
            event_name, event_args = self.feedback_events.pop(0)
            event_args = (self.name,) + event_args
            getattr(speak, event_name)(*event_args, _key=self.name)
